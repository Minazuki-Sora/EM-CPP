# 条款1：理解模板型别推导
* 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理
* 对万能引用形参进行推导时，左值实参会进行特殊处理
* 对按值传递的形参进行推导时，若实参型别中带有const或volatile饰词，会被忽略
* 模板型别推导中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用

# 条款2：理解auto型别推导
* 一般情况下，auto型别推导和模板型别推导相同，但是auto会假定用大括号括起的初始化表达式代表一个std::initializer_list，模板型别推导则不会
* 在函数返回值或lambda式的形参中使用auto，意思是使用模板型别推导而非auto型别推导

# 条款3：理解decltype
* 绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改
* 对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&
* C++14支持decltype(auto)，和auto一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是decltype的规则

# 条款4：掌握查看型别推导结果的方法
* 利用IDE编译器、编译器错误消息和Boost.TypeIndex库常常能够查看到推导得到的型别
* 有些工具产生的结果可能会无用，或者不准确。所以，理解C++型别推导规则是有必要的
